/* We simply call the root header file "App.h", giving you uWS::App and uWS::SSLApp */
#include <time.h>

#include <iostream>

#include "../uWebSockets/src/App.h"

/* This is a simple WebSocket echo server example.
 * You may compile it with "WITH_OPENSSL=1 make" or with "make" */

// 用于计算程序执行时间
inline uint64_t rdtsc() { return __builtin_ia32_rdtsc(); }

struct MSG_T {
    uint64_t before;
    uint64_t latency;
    char google[512];
};

uWS::App *globalApp;
int i{0};
void set_timer(int x) {
    std::cout << "globle -- broadcast.cpp --  befor us_timer_set() " << std::endl;
    struct us_loop_t *loop = (struct us_loop_t *)uWS::Loop::get();
    struct us_timer_t *delayTimer = us_create_timer(loop, 0, 0);
    // broadcast the unix time as millis every 8 millis
    us_timer_set(
        delayTimer,
        [](struct us_timer_t * /*t*/) {
            struct timespec ts;
            timespec_get(&ts, TIME_UTC);

            // int64_t millis = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;

            char millis[] = "abcdef";
            char google[1024];

            // std::cout << "Broadcasting timestamp: " << millis << std::endl;

            globalApp->publish("xxxx", std::string_view((char *)millis, 6), uWS::OpCode::BINARY, false);
            uint64_t before;
            uint64_t latency;
            struct MSG_T {
                uint64_t before;
                uint64_t latency;
                char google[7120];
            };
            before = rdtsc();
            struct MSG_T msg1;
            msg1.before = before;
            msg1.google[0] = 'a';
            msg1.latency = rdtsc() - before;
            before = rdtsc();
            msg1.before = before;
            globalApp->publish("GOOG", std::string_view((char *)&msg1, sizeof(struct MSG_T)), uWS::OpCode::BINARY, false);
            // globalApp->publish("GOOG", (char *)&before, uWS::OpCode::BINARY, false);
            latency = rdtsc() - before;
            std::cout << "\n publish:: main " << before << " latency: " << latency << " i: " << std::endl;
            // globalApp->publish("broadcast", std::string_view((char *) millis, 6), uWS::OpCode::BINARY, false);
            // globalApp->publish("broadcast", std::string_view((char *) &millis, sizeof(millis)), uWS::OpCode::BINARY,
            // false);
            i++;
        },
        1000, 2000);
}

struct PerSocketData {
    /* Fill with user data */
    uWS::Loop *loop;
    std::string name;
};

void LoopFunc(uWS::WebSocket<false, true, PerSocketData> *ws) {
    std::string name;
    while (true) {
        std::cout << " Loop Thread: " << std::this_thread::get_id() << std::endl;
        name = ws->getUserData()->name;
        std::cout << " Loop  get: " << std::this_thread::get_id() << name << std::endl;

        /* Check break condition. */

        std::this_thread::sleep_for(std::chrono::milliseconds(1));
        // sleep(1);
        std::cout << " Loop  get: " << std::this_thread::get_id() << name << std::endl;
        std::string result = "Mission Complete! " + name;
        std::cout << " Loop Thread defer B: " << std::this_thread::get_id() << std::endl;

        struct MSG_T msg1;
        msg1.google[0] = 'a';
        msg1.before = rdtsc();

        // ws->getUserData()->loop->defer([ws, result]() { ws->send(result, uWS::TEXT, true); });
        ws->getUserData()->loop->defer([ws, msg1]() { ws->send(std::string_view((char *)&msg1, sizeof(struct MSG_T)), uWS::BINARY, true); });
        std::cout << " Loop Thread defer E: " << std::this_thread::get_id() << std::endl;
    }
}

int main() {
    auto loop1 = uWS::Loop::get();
    int n = 1;
    /* ws->getUserData returns one of these */

    /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
     * You may swap to using uWS:App() if you don't need SSL */
    uWS::App app = uWS::App({
        /* There are example certificates in uWebSockets.js repo */
        .key_file_name = "misc/key.pem",
        .cert_file_name = "misc/cert.pem",
        .passphrase = "1234",
    });

    app.ws<PerSocketData>("/*", // ---
                          {
                              /* Settings */
                              .compression = uWS::SHARED_COMPRESSOR,
                              .maxPayloadLength = 16 * 1024 * 1024,
                              .idleTimeout = 16,
                              .maxBackpressure = 1 * 1024 * 1024,
                              .closeOnBackpressureLimit = false,
                              .resetIdleTimeoutOnSend = false,
                              .sendPingsAutomatically = true,
                              /* Handlers */
                              .upgrade = nullptr,
                              .open =
                                  [](auto *ws) {
                                      /* Open event here, you may access ws->getUserData() which points to a
                                       * PerSocketData struct */
                                      // ws->subscribe("broadcast");
                                      auto x = ws->getUserData();
                                      x->name = "tttt";
                                      x->loop = uWS::Loop::get(); // 一个线程一个loop, 一个线程可以有多个 uWS::App app1,app2
                                      std::thread th1(LoopFunc, ws);
                                      th1.detach();

                                      ws->subscribe("xxxx");
                                      //  ws->subscribe("GOOG");
                                      struct us_loop_t *loop = (struct us_loop_t *)uWS::Loop::get();
                                      struct us_timer_t *delayTimer = us_create_timer(loop, 0, 0);
                                      std::cout << "open -- broadcast.cpp --  befor us_timer_set() " << std::endl;
                                      // broadcast the unix time as millis every 8 millis
                                      us_timer_set(
                                          delayTimer,
                                          [](struct us_timer_t * /*t*/) {
                                              struct timespec ts;
                                              timespec_get(&ts, TIME_UTC);

                                              // int64_t millis = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;

                                              char millis[] = "abcdef";
                                              char google[1024];

                                              // std::cout << "Broadcasting timestamp: " << millis << std::endl;

                                              // globalApp->publish("xxxx", std::string_view((char *)millis, 6), uWS::OpCode::BINARY,
                                              //                   false);
                                              uint64_t before;
                                              uint64_t latency;

                                              before = rdtsc();
                                              struct MSG_T msg1;
                                              msg1.before = before;
                                              msg1.google[0] = 'a';
                                              msg1.latency = rdtsc() - before;
                                              before = rdtsc();
                                              msg1.before = before;
                                              // globalApp->publish("GOOG", std::string_view((char *)&msg1, sizeof(struct MSG_T)),
                                              //                   uWS::OpCode::BINARY, false);
                                              // globalApp->publish("GOOG", (char *)&before, uWS::OpCode::BINARY, false);
                                              latency = rdtsc() - before;
                                              // std::cout << "\n publish:: i-------------- " << before << " latency: " << latency <<
                                              // std::endl; globalApp->publish("broadcast", std::string_view((char *) millis, 6),
                                              // uWS::OpCode::BINARY, false); globalApp->publish("broadcast", std::string_view((char *)
                                              // &millis, sizeof(millis)), uWS::OpCode::BINARY, false);
                                          },
                                          100, 100);
                                  },
                              .message =
                                  [&](auto *ws, std::string_view message, uWS::OpCode /*opCode*/) {
                                      ws->subscribe("GOOG");
                                      std::this_thread::sleep_for(std::chrono::milliseconds(10));
                                      std::cout << "from .message !\n";
                                      // std::thread th1(LoopFunc, ws);
                                      // th1.detach();
                                      struct us_loop_t *loop = (struct us_loop_t *)uWS::Loop::get();
                                      struct us_timer_t *delayTimer = us_create_timer(loop, 0, 0);
                                      std::cout << "message -- broadcast.cpp --  befor us_timer_set() " << std::endl;
                                      // broadcast the unix time as millis every 8 millis

                                      // set_timer(delayTimer, i);
                                      // std::cout << message << std::endl;
                                  },
                              .drain =
                                  [](auto * /*ws*/) {
                                      /* Check ws->getBufferedAmount() here */
                                  },
                              .ping =
                                  [](auto * /*ws*/, std::string_view) {
                                      /* Not implemented yet */
                                  },
                              .pong =
                                  [](auto * /*ws*/, std::string_view) {
                                      /* Not implemented yet */
                                  },
                              .close =
                                  [](auto * /*ws*/, int /*code*/, std::string_view /*message*/) {
                                      /* You may access ws->getUserData() here */
                                  },
                          });

    app.listen(9001, [](auto *listen_socket) {
        if (listen_socket)
            std::cout << "Listening on port " << 9001 << std::endl;
    });

    std::cout << "-- broadcast.cpp --  befor uWS::Loop::get(); " << std::endl;
    struct us_loop_t *loop = (struct us_loop_t *)uWS::Loop::get();

    struct us_timer_t *delayTimer = us_create_timer(loop, 0, 0);
    std::cout << "-- broadcast.cpp --  befor us_timer_set() " << std::endl;
    // broadcast the unix time as millis every 8 millis
    us_timer_set(
        delayTimer,
        [](struct us_timer_t * /*t*/) {
            struct timespec ts;
            timespec_get(&ts, TIME_UTC);

            // int64_t millis = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;

            char millis[] = "abcdef";
            char google[1024];

            // std::cout << "Broadcasting timestamp: " << millis << std::endl;

            //  globalApp->publish("xxxx", std::string_view((char *)millis, 6), uWS::OpCode::BINARY, false);
            uint64_t before;
            uint64_t latency;
            before = rdtsc();
            struct MSG_T msg1;
            msg1.before = before;
            msg1.google[0] = 'a';
            msg1.latency = rdtsc() - before;
            before = rdtsc();
            msg1.before = before;
            // globalApp->publish("GOOG", std::string_view((char *)&msg1, sizeof(struct MSG_T)), uWS::OpCode::BINARY, false);
            latency = rdtsc() - before;
            // std::cout << "\n publish::  " << before << " latency: " << latency << std::endl;
            // globalApp->publish("broadcast", std::string_view((char *) millis, 6), uWS::OpCode::BINARY, false);
            // globalApp->publish("broadcast", std::string_view((char *) &millis, sizeof(millis)), uWS::OpCode::BINARY, false);
        },
        100, 100);

    globalApp = &app;

    // app.run();
    uWS::run();
}
